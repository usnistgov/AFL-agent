<!DOCTYPE html>
<html>
<head>
  <meta charset='UTF-8'>
  <title>Pipeline Builder</title>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/jsPlumb/2.15.6/js/jsplumb.min.js'></script>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; display: flex; height: 100vh; }
    #sidebar { width: 260px; height: 100vh; overflow-y: auto; border-right: 1px solid #ccc; padding: 10px; box-sizing: border-box; }
    #canvas-container { flex: 1; position: relative; }
    #canvas { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: #f7f7f7; overflow: hidden; cursor: grab; }
    #canvas.dragging { cursor: grabbing; }
    #params-pane { width: 300px; height: 100vh; overflow-y: auto; border-left: 1px solid #ccc; padding: 10px; box-sizing: border-box; background: #fff; }
    
    /* Bottom action buttons - all inline */
    #bottom-actions {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        display: flex;
        gap: 15px;
        align-items: center;
    }
    
    .action-button {
        background: #6c757d;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
        min-width: 80px;
    }
    
    .action-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    .action-button:active {
        transform: translateY(0px);
    }
    
    .action-button:disabled {
        background: #adb5bd;
        cursor: not-allowed;
        transform: none;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    /* Individual button colors */
    #copy-btn { background: #28a745; }
    #paste-btn { background: #17a2b8; }
    #load-prefab-btn { background: #6f42c1; }
    #optimize-layout { background: #fd7e14; }
    #submit-overlay { background: #007acc; }

    
    /* Hide copy/paste buttons when no selection */
    #copy-paste-buttons {
        display: none;
        gap: 10px;
    }
    
    #copy-paste-buttons.show {
        display: flex;
    }
    .op-template { border: 1px solid #ccc; padding: 5px; margin-bottom: 5px; cursor: grab; }
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .loading-text {
      color: #666;
      font-style: italic;
      padding: 10px 5px;
    }
    .node { 
      position: absolute; 
      padding: 15px; 
      background: #fff; 
      border: 2px solid #333; 
      border-radius: 8px;
      min-width: 150px;
      text-align: center;
    }
    .node.selected { 
      border-color: #007acc; 
      box-shadow: 0 0 10px rgba(0, 122, 204, 0.5); 
    }
    .node-title { 
      font-weight: bold; 
      margin-bottom: 10px; 
      font-size: 14px;
    }
    .node-vars { 
      display: flex; 
      flex-direction: column; 
      gap: 5px; 
    }
    .node-vars input { 
      padding: 4px; 
      border: 1px solid #ccc; 
      border-radius: 3px; 
      font-size: 12px;
    }
    .node-vars label { 
      font-size: 11px; 
      color: #666; 
    }
    .connector { 
      width: 12px; 
      height: 12px; 
      background: #000; 
      border-radius: 50%; 
      position: absolute; 
      left: 50%; 
      transform: translateX(-50%); 
    }
    .connector.input { top: -6px; }
    .connector.output { bottom: -6px; }
    .param-tile {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      background: #f9f9f9;
      cursor: pointer;
      transition: all 0.2s;
    }
    .param-tile:hover {
      background: #f0f0f0;
      border-color: #bbb;
    }
    .param-tile.selected {
      border-color: #007acc;
      background: #e8f4fd;
    }
    .param-tile-title {
      font-weight: bold;
      margin-bottom: 10px;
      color: #333;
    }
    .param-group {
      margin-bottom: 10px;
    }
    .param-group label {
      display: block;
      font-size: 12px;
      color: #666;
      margin-bottom: 2px;
    }
    .param-group input {
      width: 100%;
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 13px;
      box-sizing: border-box;
    }
    #params-pane h3 {
      margin-top: 0;
      color: #333;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    .delete-node {
      position: absolute;
      top: -10px;
      right: -10px;
      width: 20px;
      height: 20px;
      background: #ff5c5c;
      color: white;
      border-radius: 50%;
      text-align: center;
      line-height: 20px;
      cursor: pointer;
      font-weight: bold;
      border: 2px solid white;
    }
    .delete-node:hover {
      background: #c0392b;
    }
    #undo-banner {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 1000;
      display: none;
    }
    #undo-banner button {
      margin-left: 15px;
      background: #007acc;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
    }
    .node.deleted {
        /* Just for state tracking, no visual change */
    }
    
    /* Search field styling */
    #search-container {
      margin-bottom: 15px;
      position: relative;
    }
    
    #op-search {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
      background: white;
    }
    
    #op-search:focus {
      outline: none;
      border-color: #007acc;
      box-shadow: 0 0 5px rgba(0, 122, 204, 0.3);
    }
    
    #search-clear {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      font-size: 16px;
      width: 20px;
      height: 20px;
      display: none;
      align-items: center;
      justify-content: center;
    }
    
    #search-clear:hover {
      color: #333;
    }
    
    .op-template.hidden {
      display: none;
    }
    
    #no-results {
      display: none;
      color: #666;
      font-style: italic;
      padding: 10px 5px;
      text-align: center;
    }
    
    /* Multi-selection and copy-paste styling */
    .node.multi-selected { 
     border-color: #007acc; 
      box-shadow: 0 0 10px rgba(42, 40, 167, 0.5); 
      background: #e8f4fd;
    }
    
    .node.copying {
      animation: copyPulse 0.3s ease-in-out;
    }
    
    @keyframes copyPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    #copy-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #007acc;
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      z-index: 1001;
      display: none;
      font-size: 14px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    
    #paste-preview {
      position: absolute;
      pointer-events: none;
      opacity: 0.7;
      z-index: 500;
    }
    
    #paste-preview .node {
      border: 2px dashed #007acc;
      background: rgba(0, 122, 204, 0.1);
    }
    
    /* Info button styling for sidebar operations */
    .op-info-btn {
      float: right;
      background: #007acc;
      color: white;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      margin-left: 6px;
      cursor: pointer;
    }
    
    .op-info-btn:hover {
      background: #005fa3;
    }
    
    /* Info button styling for nodes in the canvas */
    .info-btn {
      position: absolute;
      top: -10px;
      left: -10px;
      width: 20px;
      height: 20px;
      background: #3498db;
      color: white;
      border-radius: 50%;
      text-align: center;
      line-height: 20px;
      cursor: pointer;
      font-weight: bold;
      border: 2px solid white;
    }
    
    .info-btn:hover {
      background: #217dbb;
    }
    /* Edge glow indicators */
    .edge-glow {position: absolute; pointer-events: none; z-index: 1500; opacity: 0; transition: opacity 0.3s;}
    .edge-glow.top {top: 0; left: 0; right: 0; height: 25px; background: linear-gradient(to bottom, rgba(0,122,204,0.6), transparent);}
    .edge-glow.bottom {bottom: 0; left: 0; right: 0; height: 25px; background: linear-gradient(to top, rgba(0,122,204,0.6), transparent);}
    .edge-glow.left {top: 0; left: 0; bottom: 0; width: 25px; background: linear-gradient(to right, rgba(0,122,204,0.6), transparent);} 
    .edge-glow.right {top: 0; right: 0; bottom: 0; width: 25px; background: linear-gradient(to left, rgba(0,122,204,0.6), transparent);} 
  </style>
</head>
<body>
      <div id='sidebar'>
      <h3>Pipeline Ops</h3>
      <div id='search-container'>
        <input type='text' id='op-search' placeholder='Search operations...' autocomplete='off'>
        <button id='search-clear'>×</button>
      </div>
    <div id='op-list'>
      <div class='loading-text'>
        <span class='loading-spinner'></span>Loading pipeline operations...
      </div>
      <div id='no-results'>No operations found</div>
    </div>
  </div>
  <div id='canvas-container'>
    <div id='canvas'></div>
    <!-- Edge glow indicators -->
    <div class='edge-glow top'></div>
    <div class='edge-glow bottom'></div>
    <div class='edge-glow left'></div>
    <div class='edge-glow right'></div>
  </div>
  <div id='params-pane'>
    <h3>Node Parameters</h3>
    <div id='param-tiles'></div>
  </div>

  <div id='undo-banner'>
    Node deleted. <button id='undo-delete'>Undo</button>
  </div>

  <!-- Bottom action buttons - all inline -->
  <div id='bottom-actions'>
    <button id='load-prefab-btn' class='action-button'>Load Prefab</button>
    <button id='save-prefab-btn' class='action-button'>Save Prefab</button>
    <button id='optimize-layout' class='action-button'>Optimize Layout</button>
    <button id='submit-overlay' class='action-button'>Submit Pipeline</button>
    <div id='copy-paste-buttons'>
      <button id='copy-btn' class='action-button' disabled>Copy</button>
      <button id='paste-btn' class='action-button' disabled>Paste</button>
    </div>
  </div>
  
  <!-- Copy indicator -->
  <div id='copy-indicator'>Copied to clipboard!</div>

  <!-- Prefab Selection Modal -->
  <div id='prefab-modal' style='display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000;'>
    <div style='position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 8px; max-width: 500px; width: 90%;'>
      <h3 style='margin-top: 0;'>Load Prefab Pipeline</h3>
      <p style='color: #666; margin-bottom: 20px;'>Select a prefabricated pipeline to load:</p>
      <select id='prefab-select' style='width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; margin-bottom: 20px;'>
        <option value=''>-- Select a prefab --</option>
      </select>
      <div style='text-align: right; margin-top: 20px;'>
        <button id='cancel-prefab' style='margin-right: 10px; padding: 8px 16px; border: 1px solid #ccc; background: white; border-radius: 4px; cursor: pointer;'>Cancel</button>
        <button id='load-prefab' style='padding: 8px 16px; background: #6f42c1; color: white; border: none; border-radius: 4px; cursor: pointer;' disabled>Load Prefab</button>
      </div>
    </div>
  </div>

  <!-- Connection Modal -->
  <div id='connection-modal' style='display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000;'>
    <div style='position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; max-width: 600px; width: 90%;'>
      <h3>Connect Variables</h3>
      <div style='display: flex; gap: 20px; margin: 20px 0;'>
        <div style='flex: 1;'>
          <h4>Source Outputs</h4>
          <div id='source-outputs'></div>
        </div>
        <div style='flex: 1;'>
          <h4>Target Inputs</h4>
          <div id='target-inputs'></div>
        </div>
      </div>
      <div id='connections-preview' style='margin: 15px 0; padding: 10px; background: #f5f5f5; border-radius: 4px; display: none;'>
        <h5>Connections to make:</h5>
        <div id='connections-list'></div>
      </div>
      <div style='text-align: right; margin-top: 20px;'>
        <button id='cancel-connection' style='margin-right: 10px; padding: 8px 16px; border: 1px solid #ccc; background: white; border-radius: 4px; cursor: pointer;'>Cancel</button>
        <button id='apply-connections' style='padding: 8px 16px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer;'>Apply Connections</button>
      </div>
    </div>
  </div>

  <!-- Docstring Modal -->
  <div id='doc-modal' style='display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000;'>
    <div style='position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; max-width: 600px; width: 90%; max-height: 80%; overflow-y: auto;'>
      <h3 id='doc-modal-title' style='margin-top: 0;'>Documentation</h3>
      <pre id='doc-modal-content' style='white-space: pre-wrap; font-family: monospace; font-size: 13px;'></pre>
      <div style='text-align: right; margin-top: 15px;'>
        <button id='doc-modal-close' style='padding: 6px 12px; border: 1px solid #ccc; background: white; border-radius: 4px; cursor: pointer;'>Close</button>
      </div>
    </div>
  </div>

  <script>
    const instance = jsPlumb.getInstance({Container: 'canvas'});
    const opList = document.getElementById('op-list');
    const canvas = document.getElementById('canvas');
    const prefabSelect = document.getElementById('prefab-select');
    const paramTiles = document.getElementById('param-tiles');
    let counter = 0;
    let selectedNode = null;
    let lastDeletedNode = null;
    let isLoadingPipeline = false;
    let isProgrammaticConnection = false;
    
    // Copy-paste functionality variables
    let selectedNodes = new Set();
    let clipboard = [];
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    // UI elements
    const copyBtn = document.getElementById('copy-btn');
    const pasteBtn = document.getElementById('paste-btn');
    const prefabModal = document.getElementById('prefab-modal');
    const loadPrefabModalBtn = document.getElementById('load-prefab-btn');

    // Authentication function
    async function ensureAuthenticated() {
      let token = localStorage.getItem('token');
      if (!token) {
        try {
          const response = await fetch('/login', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              username: 'user',
              password: 'domo_arigato'
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            token = data.token;
            localStorage.setItem('token', token);
          } else {
            throw new Error('Login failed');
          }
        } catch (error) {
          console.error('Authentication error:', error);
          throw new Error('Failed to authenticate');
        }
      }
      return token;
    }

    // Helper function to make authenticated requests
    async function authenticatedFetch(url, options = {}) {
      const token = await ensureAuthenticated();
      const headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
        ...options.headers
      };
      
      return fetch(url, {
        ...options,
        headers
      });
    }
    
    // Canvas panning variables
    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;
    let currentPanX = 0;
    let currentPanY = 0;
    
    // Search functionality variables
    let allOperations = [];
    const searchInput = document.getElementById('op-search');
    const searchClear = document.getElementById('search-clear');
    const noResults = document.getElementById('no-results');
    
    // Simple fuzzy search function
    function fuzzyMatch(pattern, text) {
      pattern = pattern.toLowerCase();
      text = text.toLowerCase();
      
      // If exact substring match, give high score
      if (text.includes(pattern)) {
        return 100;
      }
      
      // Fuzzy matching - check if all characters of pattern appear in order in text
      let patternIndex = 0;
      let score = 0;
      
      for (let i = 0; i < text.length && patternIndex < pattern.length; i++) {
        if (text[i] === pattern[patternIndex]) {
          score += (text.length - i); // Earlier matches get higher score
          patternIndex++;
        }
      }
      
      // Return score only if all pattern characters were found
      return patternIndex === pattern.length ? score : 0;
    }
    
    function filterOperations(searchTerm) {
      const operations = document.querySelectorAll('.op-template');
      let visibleCount = 0;
      
      if (!searchTerm.trim()) {
        // Show all operations if search is empty
        operations.forEach(op => {
          op.classList.remove('hidden');
          visibleCount++;
        });
        noResults.style.display = 'none';
        searchClear.style.display = 'none';
        return;
      }
      
      // Show clear button when there's search text
      searchClear.style.display = 'flex';
      
      // Score and filter operations
      const scoredOps = [];
      operations.forEach(op => {
        const name = op.textContent;
        const score = fuzzyMatch(searchTerm, name);
        
        if (score > 0) {
          scoredOps.push({ element: op, score: score, name: name });
          op.classList.remove('hidden');
          visibleCount++;
        } else {
          op.classList.add('hidden');
        }
      });
      
      // Sort by score (higher is better) and then alphabetically
      scoredOps.sort((a, b) => {
        if (b.score !== a.score) {
          return b.score - a.score;
        }
        return a.name.localeCompare(b.name);
      });
      
      // Reorder DOM elements based on search relevance
      scoredOps.forEach(item => {
        opList.appendChild(item.element);
      });
      
      // Show "no results" message if nothing found
      noResults.style.display = visibleCount === 0 ? 'block' : 'none';
    }
    
    // Set up search event listeners
    searchInput.addEventListener('input', (e) => {
      filterOperations(e.target.value);
    });
    
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        searchInput.value = '';
        filterOperations('');
        searchInput.blur();
      }
    });
    
    searchClear.addEventListener('click', () => {
      searchInput.value = '';
      filterOperations('');
      searchInput.focus();
    });
    
    // Copy-paste functionality
    function getAllVariableNames() {
      const variableNames = new Set();
      document.querySelectorAll('.node:not(.deleted)').forEach(node => {
        // Check input variables
        node.querySelectorAll('input[data-input], input[data-output]').forEach(input => {
          if (input.value.trim()) {
            variableNames.add(input.value.trim());
          }
        });
      });
      return variableNames;
    }
    
    function generateUniqueVariableName(baseName, existingNames) {
      if (!existingNames.has(baseName)) {
        return baseName;
      }
      
      let counter = 1;
      let newName;
      do {
        newName = `${baseName}_${counter}`;
        counter++;
      } while (existingNames.has(newName));
      
      return newName;
    }
    
    function copySelectedNodes() {
      if (selectedNodes.size === 0) return;
      
      clipboard = [];
      const existingNames = getAllVariableNames();
      
      selectedNodes.forEach(node => {
        // Get all parameters from the param tile
        const nodeData = {
          fqcn: node.dataset.fqcn,
          args: {},
          metadata: null
        };
        
        // Extract metadata
        const opTemplate = document.querySelector(`[data-fqcn="${node.dataset.fqcn}"]`);
        if (opTemplate && opTemplate.dataset.metadata) {
          nodeData.metadata = JSON.parse(opTemplate.dataset.metadata);
        }
        
        // Get parameters from the param tile
        const paramInputs = document.querySelectorAll(`input[data-node-id="${node.id}"][data-param]`);
        paramInputs.forEach(inp => {
          if (inp.value.trim()) {
            let value = parseValue(inp.value);
            
            // If this is a variable parameter, make it unique
            if (inp.dataset.param.includes('variable') || 
                inp.dataset.param.includes('input') || 
                inp.dataset.param.includes('output')) {
              if (typeof value === 'string') {
                value = generateUniqueVariableName(value, existingNames);
                existingNames.add(value); // Add to set so subsequent copies don't collide
              }
            }
            
            nodeData.args[inp.dataset.param] = value;
          }
        });
        
        clipboard.push(nodeData);
        
        // Visual feedback
        node.classList.add('copying');
        setTimeout(() => node.classList.remove('copying'), 300);
      });
      
      // Show copy indicator
      const indicator = document.getElementById('copy-indicator');
      indicator.textContent = `Copied ${clipboard.length} operation${clipboard.length > 1 ? 's' : ''}!`;
      indicator.style.display = 'block';
      setTimeout(() => {
        indicator.style.display = 'none';
      }, 2000);
    }
    
    function pasteNodes() {
      if (clipboard.length === 0) return;
      
      const canvasRect = canvas.getBoundingClientRect();
      const startX = canvasRect.width / 2 + currentPanX;
      const startY = canvasRect.height / 2 + currentPanY;
      
      // Clear current selection
      clearSelection();
      
      clipboard.forEach((nodeData, index) => {
        const offsetX = startX + (index * 50); // Stagger horizontally
        const offsetY = startY + (index * 20); // Slight vertical offset
        
        // Create new node
        const params = nodeData.args || {};
        const node = addNode(nodeData.fqcn, params, offsetX, offsetY, nodeData.metadata);
        
        // Update node index
        const existingNodes = document.querySelectorAll('.node');
        node.dataset.opIndex = existingNodes.length - 1;
        
        // Select the pasted node for visual feedback
        selectedNodes.add(node);
        node.classList.add('multi-selected');
      });
      
      // Update selected node for param tile display
      if (selectedNodes.size === 1) {
        selectedNode = Array.from(selectedNodes)[0];
        selectNode(selectedNode);
      }
      updateEdgeGlow();
    }
    
         function clearSelection() {
       selectedNodes.forEach(node => {
         node.classList.remove('selected', 'multi-selected');
       });
       selectedNodes.clear();
       selectedNode = null;
       
       // Clear param tile selection
       document.querySelectorAll('.param-tile.selected').forEach(t => t.classList.remove('selected'));
       
       // Update button states
       updateButtonStates();
     }
    
    function toggleNodeSelection(node, multiSelect = false) {
      if (!multiSelect) {
        clearSelection();
      }
      
      if (selectedNodes.has(node)) {
        // Deselect
        selectedNodes.delete(node);
        node.classList.remove('selected', 'multi-selected');
        if (selectedNode === node) {
          selectedNode = null;
        }
      } else {
        // Select
        selectedNodes.add(node);
        node.classList.add('multi-selected');
        selectedNode = node; // For param tile display
      }
      
             // Update param tile display for single selection
       if (selectedNodes.size === 1) {
         selectNode(Array.from(selectedNodes)[0]);
       } else if (selectedNodes.size === 0) {
         // Clear param tile selection
         document.querySelectorAll('.param-tile.selected').forEach(t => t.classList.remove('selected'));
       }
       
       // Update button states
       updateButtonStates();
     }
     
     // Update button states based on selection
     function updateButtonStates() {
       const copyPasteButtons = document.getElementById('copy-paste-buttons');
       
       // Show/hide copy-paste buttons based on selection
       if (selectedNodes.size > 0) {
         copyPasteButtons.classList.add('show');
       } else {
         copyPasteButtons.classList.remove('show');
       }
       
       // Update button enabled/disabled states
       copyBtn.disabled = selectedNodes.size === 0;
       pasteBtn.disabled = clipboard.length === 0;
     }
     
     // Button event handlers
     copyBtn.addEventListener('click', () => {
       copySelectedNodes();
       updateButtonStates();
     });
     
     pasteBtn.addEventListener('click', () => {
       pasteNodes();
       updateButtonStates();
     });
     
     // Prefab modal handlers
     loadPrefabModalBtn.addEventListener('click', () => {
       prefabModal.style.display = 'block';
     });
     
     document.getElementById('cancel-prefab').addEventListener('click', () => {
       prefabModal.style.display = 'none';
     });
     
     document.getElementById('prefab-select').addEventListener('change', (e) => {
       document.getElementById('load-prefab').disabled = !e.target.value;
     });
 
      async function loadOps() {
      try {
        const res = await authenticatedFetch('/pipeline_ops', {
          method: 'GET'
        });
        const ops = await res.json();
        
        // Clear loading indicator
        opList.innerHTML = '';
        
        ops.forEach(op => {
          const div = document.createElement('div');
          div.className = 'op-template';
          div.textContent = op.name;
          div.draggable = true;
          div.dataset.fqcn = op.fqcn;
          div.dataset.params = JSON.stringify(op.parameters);

          // Store full metadata including docstring
          const metadataObj = {
            input_params: op.input_params || [],
            output_params: op.output_params || [],
            docstring: op.docstring || ''
          };
          div.dataset.metadata = JSON.stringify(metadataObj);

          // Add info button for docstring
          const infoBtn = document.createElement('span');
          infoBtn.className = 'op-info-btn';
          infoBtn.textContent = 'i';
          infoBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showDocModal(op.docstring || '', op.name);
          });
          // Prevent dragging when clicking the info button
          infoBtn.addEventListener('mousedown', (e) => e.stopPropagation());
          infoBtn.addEventListener('dragstart', (e) => e.preventDefault());

          div.appendChild(infoBtn);

          div.addEventListener('dragstart', e => {
            e.dataTransfer.setData('text/plain', div.dataset.fqcn);
          });
          opList.appendChild(div);
        });
      } catch (error) {
        opList.innerHTML = '<div class="loading-text" style="color: #e74c3c;">Failed to load pipeline operations</div>';
        console.error('Error loading pipeline ops:', error);
      }
      // Reset pan position
      currentPanX = 0;
      currentPanY = 0;
      // Clear any pending undos
      lastDeletedNode = null;
      document.getElementById('undo-banner').style.display = 'none';
    }

    async function loadPrefabs() {
      const res = await authenticatedFetch('/prefab_names', {
        method: 'GET'
      });
      if (!res.ok) return;
      const names = await res.json();
      names.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n;
        opt.textContent = n;
        prefabSelect.appendChild(opt);
      });
    }

    function clearCanvas() {
      instance.deleteEveryConnection();
      instance.deleteEveryEndpoint();
      canvas.innerHTML = '';
      paramTiles.innerHTML = '';
      counter = 0;
      selectedNode = null;
      
      // Reset pan position
      currentPanX = 0;
      currentPanY = 0;
    }

    function loadPipeline(data) {
      isLoadingPipeline = true; // Disable connection dialog during loading
      clearCanvas();
      
      // Handle both old format (array) and new format (object with ops and connections)
      const ops = Array.isArray(data) ? data : data.ops;
      const connections = data.connections || [];
      
      let x = 50;
      let y = 50;
      const nodes = [];
      const nodesByOutputVar = new Map();
      
            ops.forEach((op, index) => {
 
        if (!op.name) {
          op.name = op.class;
        }
        // Try to find metadata for this operation class
        const opTemplate = document.querySelector(`[data-fqcn="${op.class}"]`);
        let metadata = null;
        if (opTemplate && opTemplate.dataset.metadata) {
          try {
            metadata = JSON.parse(opTemplate.dataset.metadata);
          } catch (e) {
            console.warn('Failed to parse metadata for operation:', op.class, e);
            metadata = null;
          }
        }
        
        // If no metadata available, infer input/output parameters from operation args
        if (!metadata && op.args) {
          metadata = inferMetadataFromArgs(op.args);
        }
        
        const node = addNode(op.name || op.class, op.args || {}, x, y, metadata);
        
        // Store the operation index on the node for lookup
        node.dataset.opIndex = index;
        
        if (op.args) {
          // Update parameters in the param tile
          const paramInputs = document.querySelectorAll(`input[data-node-id="${node.id}"][data-param]`);
          paramInputs.forEach(inp => {
            const val = op.args[inp.dataset.param];
            if (val !== undefined) {
              if (typeof val === 'object') {
                inp.value = JSON.stringify(val);
              } else {
                inp.value = val;
              }
            }
          });
          
          // Handle output variables dynamically
          if (metadata && metadata.output_params) {
            metadata.output_params.forEach(paramName => {
              const outputInput = node.querySelector(`input[data-output="${paramName}"]`);
              if (op.args[paramName] && outputInput) {
                outputInput.value = op.args[paramName];
                // Map output variables to nodes for connection lookup
                nodesByOutputVar.set(op.args[paramName], node);
              }
            });
          } else if (op.args.output_variable) {
            const outputInput = node.querySelector('input[data-output="output_variable"]');
            if (outputInput) {
              outputInput.value = op.args.output_variable;
              nodesByOutputVar.set(op.args.output_variable, node);
            }
          }
          
          // Handle input variables dynamically
          if (metadata && metadata.input_params) {
            metadata.input_params.forEach(paramName => {
              const inputInput = node.querySelector(`input[data-input="${paramName}"]`);
              if (op.args[paramName] && inputInput) {
                inputInput.value = op.args[paramName];
              }
            });
          } else if (op.args.input_variable) {
            const inputInput = node.querySelector('input[data-input="input_variable"]');
            if (inputInput) {
              inputInput.value = op.args.input_variable;
            }
          }
        }
        nodes.push({node: node, op: op, index: index});
        y += 150;
      });

            // Connect nodes using the backend-provided connection information
      isProgrammaticConnection = true;
      connections.forEach(conn => {
        const sourceNode = nodes.find(n => n.index === conn.source_index);
        const targetNode = nodes.find(n => n.index === conn.target_index);
        
        if (sourceNode && targetNode) {
          instance.connect({
            source: sourceNode.node.querySelector('[data-role="out"]'),
            target: targetNode.node.querySelector('[data-role="in"]'),
            connector: ['Bezier', { curviness: 30 }],
            anchors: ['Center', 'Center']
          });
        }
      });
      isProgrammaticConnection = false;
      
      // Optimize layout after loading pipeline
      if (connections.length > 0) {
        optimizeLayout(connections);
      }
      
      isLoadingPipeline = false; // Re-enable connection dialog
      updateEdgeGlow();
    }

    async function loadCurrentPipeline() {
      const res = await authenticatedFetch('/current_pipeline', {
        method: 'GET'
      });
      if (res.ok) {
        const data = await res.json();
        // Handle both legacy (array) and new (object with ops/connections) formats
        if ((Array.isArray(data) && data.length) || (data && Array.isArray(data.ops) && data.ops.length)) {
          loadPipeline(data);
        }
      }
    }

    function selectNode(node) {
      // Remove selection from all nodes and tiles
      document.querySelectorAll('.node.selected').forEach(n => n.classList.remove('selected'));
      document.querySelectorAll('.param-tile.selected').forEach(t => t.classList.remove('selected'));
      
      // Select the new node
      selectedNode = node;
      node.classList.add('selected');
      
      // Find and select corresponding param tile
      const tile = document.querySelector(`.param-tile[data-node-id="${node.id}"]`);
      if (tile) {
        tile.classList.add('selected');
        tile.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    function selectNodeFromTile(nodeId) {
      const node = document.getElementById(nodeId);
      if (node) {
        selectNode(node);
      }
    }

    function createParamTile(node, fqcn, params, opMetadata) {
      const tile = document.createElement('div');
      tile.className = 'param-tile';
      tile.dataset.nodeId = node.id;
      
      const title = document.createElement('div');
      title.className = 'param-tile-title';
      title.textContent = fqcn.split('.').pop();
      tile.appendChild(title);

      Object.entries(params).forEach(([key, val]) => {
        const group = document.createElement('div');
        group.className = 'param-group';
        
        const label = document.createElement('label');
        label.textContent = key;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.dataset.param = key;
        input.dataset.nodeId = node.id;
        
        // Mark input/output parameters for special handling
        if (opMetadata && opMetadata.input_params && opMetadata.input_params.includes(key)) {
          input.dataset.isInputParam = 'true';
        }
        if (opMetadata && opMetadata.output_params && opMetadata.output_params.includes(key)) {
          input.dataset.isOutputParam = 'true';
        }
        
        if (val !== null) {
          if (typeof val === 'object') {
            input.value = JSON.stringify(val);
          } else {
            input.value = val;
          }
        }
        
        // Add change listener to update connections when parameters change
        input.addEventListener('change', (e) => {
          updateNodeAndTileInputs(node.id, key, e.target.value);
          debounce(updateConnections, 500)();
        });
        
        group.appendChild(label);
        group.appendChild(input);
        tile.appendChild(group);
      });

      tile.addEventListener('click', () => selectNodeFromTile(node.id));
      paramTiles.appendChild(tile);
      return tile;
    }

    // Function to infer input/output parameters from operation arguments
    function inferMetadataFromArgs(args) {
      const input_params = [];
      const output_params = [];
      
      Object.keys(args).forEach(paramName => {
        // Parameters that represent input variables
        if ((paramName.endsWith('_variable') && paramName.includes('input')) || 
            paramName === 'input_variable' || paramName === 'input_variables' ||
            paramName.endsWith('_input_variable') || paramName === 'sas_variable' ||
            paramName === 'sas_err_variable' || paramName === 'q_variable' ||
            paramName === 'feature_input_variable' || paramName === 'predictor_input_variable' ||
            paramName === 'grid_variable' || paramName.endsWith('_var')) {
          input_params.push(paramName);
        }
        // Parameters that represent output variables or prefixes  
        else if ((paramName.endsWith('_variable') && paramName.includes('output')) || 
                 paramName === 'output_variable' || paramName === 'output_variables' ||
                 paramName === 'output_prefix' || paramName.endsWith('_output_variable')) {
          output_params.push(paramName);
        }
      });
      
      return {
        input_params: input_params,
        output_params: output_params
      };
    }

    // Get input/output variables from a node
    function getNodeVariables(node) {
      const inputs = [];
      const outputs = [];
      
      // Get input variables
      const inputElements = node.querySelectorAll('input[data-input]');
      inputElements.forEach(input => {
        const paramName = input.getAttribute('data-input');
        const value = input.value || '';
        inputs.push({ paramName, value, element: input });
      });
      
      // Get output variables (exclude output_prefix as it's not a connectable variable)
      const outputElements = node.querySelectorAll('input[data-output]');
      outputElements.forEach(output => {
        const paramName = output.getAttribute('data-output');
        const value = output.value || '';
        
        // Skip output_prefix as it's a configuration parameter, not a connectable variable
        if (paramName !== 'output_prefix') {
          outputs.push({ paramName, value, element: output });
        }
      });
      
      return { inputs, outputs };
    }

    // Handle new connections between nodes
    function handleNewConnection(sourceNode, targetNode) {
      const sourceVars = getNodeVariables(sourceNode);
      const targetVars = getNodeVariables(targetNode);
      
      // If source has no outputs, we can't make any connections
      if (sourceVars.outputs.length === 0) {
        alert('The source node has no output variables to connect.');
        return;
      }
      
      // If target has no inputs, we can't make any connections
      if (targetVars.inputs.length === 0) {
        alert('The target node has no input variables to connect to.');
        return;
      }
      
      // Check if we need to show modal or can auto-connect
      const needsModal = sourceVars.outputs.length > 1 || targetVars.inputs.length > 1;
      
      if (needsModal) {
        showConnectionModal(sourceNode, targetNode, sourceVars, targetVars);
      } else if (sourceVars.outputs.length === 1 && targetVars.inputs.length === 1) {
        // Auto-connect single input to single output
        const sourceOutput = sourceVars.outputs[0];
        const targetInput = targetVars.inputs[0];
        makeConnection(sourceOutput, targetInput);
      }
    }

    // Show the connection modal
    function showConnectionModal(sourceNode, targetNode, sourceVars, targetVars) {
      const modal = document.getElementById('connection-modal');
      const sourceOutputsDiv = document.getElementById('source-outputs');
      const targetInputsDiv = document.getElementById('target-inputs');
      const connectionsPreview = document.getElementById('connections-preview');
      const connectionsList = document.getElementById('connections-list');
      
      // Clear previous content
      sourceOutputsDiv.innerHTML = '';
      targetInputsDiv.innerHTML = '';
      connectionsList.innerHTML = '';
      connectionsPreview.style.display = 'none';
      
      // Track pending connections
      const pendingConnections = [];
      let selectedOutput = null;
      
      // Create source output buttons
      sourceVars.outputs.forEach(output => {
        const button = document.createElement('div');
        button.className = 'variable-button';
        button.style.cssText = 'padding: 8px 12px; margin: 4px 0; border: 2px solid #ddd; border-radius: 4px; cursor: pointer; background: white;';
        button.innerHTML = `<strong>${output.paramName}</strong><br><small style="color: #666;">${output.value || '(not set)'}</small>`;
        
        button.addEventListener('click', () => {
          // Clear previous selection
          sourceOutputsDiv.querySelectorAll('.variable-button').forEach(b => {
            b.style.borderColor = '#ddd';
            b.style.background = 'white';
          });
          
          // Select this output
          selectedOutput = output;
          button.style.borderColor = '#007acc';
          button.style.background = '#e8f4fd';
        });
        
        sourceOutputsDiv.appendChild(button);
      });
      
      // Create target input buttons
      targetVars.inputs.forEach(input => {
        const button = document.createElement('div');
        button.className = 'variable-button';
        button.style.cssText = 'padding: 8px 12px; margin: 4px 0; border: 2px solid #ddd; border-radius: 4px; cursor: pointer; background: white;';
        button.innerHTML = `<strong>${input.paramName}</strong><br><small style="color: #666;">${input.value || '(not set)'}</small>`;
        
        button.addEventListener('click', () => {
          if (!selectedOutput) {
            alert('Please select an output variable first');
            return;
          }
          
          // Add to pending connections
          const connection = {
            source: selectedOutput,
            target: input
          };
          
          // Check if connection already exists
          const exists = pendingConnections.some(c => 
            c.source.paramName === connection.source.paramName && 
            c.target.paramName === connection.target.paramName
          );
          
          if (!exists) {
            pendingConnections.push(connection);
            updateConnectionsPreview();
          }
          
          // Clear output selection
          selectedOutput = null;
          sourceOutputsDiv.querySelectorAll('.variable-button').forEach(b => {
            b.style.borderColor = '#ddd';
            b.style.background = 'white';
          });
        });
        
        targetInputsDiv.appendChild(button);
      });
      
      function updateConnectionsPreview() {
        if (pendingConnections.length > 0) {
          connectionsPreview.style.display = 'block';
          connectionsList.innerHTML = pendingConnections.map((conn, index) => 
            `<div style="padding: 4px 0; display: flex; justify-content: space-between; align-items: center;">
              <span>${conn.source.paramName} → ${conn.target.paramName}</span>
              <button onclick="removePendingConnection(${index})" style="background: #ff5c5c; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer;">×</button>
            </div>`
          ).join('');
        } else {
          connectionsPreview.style.display = 'none';
        }
      }
      
      // Store pending connections globally for removal function
      window.pendingConnections = pendingConnections;
      window.updateConnectionsPreview = updateConnectionsPreview;
      
      // Show modal
      modal.style.display = 'block';
      
      // Handle modal buttons
      document.getElementById('cancel-connection').onclick = () => {
        modal.style.display = 'none';
      };
      
      document.getElementById('apply-connections').onclick = () => {
        pendingConnections.forEach(conn => {
          makeConnection(conn.source, conn.target);
        });
        modal.style.display = 'none';
        // Trigger connection update
        debounce(updateConnections, 500)();
      };
    }

    // Remove a pending connection
    function removePendingConnection(index) {
      window.pendingConnections.splice(index, 1);
      window.updateConnectionsPreview();
    }

    // Make a connection between an output and input variable
    function makeConnection(sourceOutput, targetInput) {
      if (!sourceOutput.value) {
        alert('Source output variable is not set');
        return;
      }
      
      const isPlural = targetInput.paramName.endsWith('s');
      let newValue;
      
      if (isPlural) {
        // Append to existing array
        let currentValue = targetInput.value || '[]';
        try {
          const currentArray = JSON.parse(currentValue);
          if (Array.isArray(currentArray)) {
            if (!currentArray.includes(sourceOutput.value)) {
              currentArray.push(sourceOutput.value);
            }
            newValue = JSON.stringify(currentArray);
          } else {
            // Not an array, create new array
            newValue = JSON.stringify([sourceOutput.value]);
          }
        } catch (e) {
          // Invalid JSON, create new array
          newValue = JSON.stringify([sourceOutput.value]);
        }
      } else {
        // Replace existing value
        newValue = sourceOutput.value;
      }
      
      // Update the target input element
      targetInput.element.value = newValue;
      
      // Update the corresponding parameter tile
      updateNodeAndTileInputs(targetInput.element.closest('.node').id, targetInput.paramName, newValue);
    }

    // Debounce function to limit API calls
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    async function updateConnections() {
      const ops = buildOps();
      if (ops.length === 0) return;
      
      try {
        const opsParam = encodeURIComponent(JSON.stringify(ops));
        const res = await authenticatedFetch(`/analyze_pipeline?ops=${opsParam}`, {
          method: 'GET'
        });
        
        if (res.ok) {
          const data = await res.json();
          
          // Set flag to prevent connection dialog during programmatic updates
          isProgrammaticConnection = true;
          
          // Clear existing connections
          instance.deleteEveryConnection();
          
          // Recreate connections based on analysis
          const nodesByOutputVar = new Map();
          const nodes = Array.from(document.querySelectorAll('.node'));
          
          nodes.forEach(node => {
            // Check all output parameter inputs for this node
            const outputInputs = node.querySelectorAll('input[data-output]');
            outputInputs.forEach(outInput => {
              if (outInput && outInput.value) {
                nodesByOutputVar.set(outInput.value, node);
              }
            });
          });
          
          data.connections.forEach(conn => {
            const sourceNode = nodes.find(node => {
              return parseInt(node.dataset.opIndex) === conn.source_index;
            });
            const targetNode = nodes.find(node => {
              return parseInt(node.dataset.opIndex) === conn.target_index;
            });
            
            if (sourceNode && targetNode) {
              instance.connect({
                source: sourceNode.querySelector('[data-role="out"]'),
                target: targetNode.querySelector('[data-role="in"]'),
                connector: ['Bezier', { curviness: 30 }],
                anchors: ['Center', 'Center']
              });
            }
          });
          
          // Optimize layout after connections are established
          optimizeLayout(data.connections);
          
          // Reset flag after programmatic updates are complete
          isProgrammaticConnection = false;
        }
      } catch (error) {
        console.error('Error updating connections:', error);
      }
    }

    function optimizeLayout(connections) {
      const nodes = Array.from(document.querySelectorAll('.node'));
      if (nodes.length <= 1) return;
      
      console.log('Applying Sugiyama-style hierarchy layout');
      
      const graph = buildDirectedGraph(nodes, connections);
      let layers = assignLayers(graph);
      
      // Add dummy nodes for edges spanning multiple layers
      const { graph: augmentedGraph, layers: augmentedLayers } = addDummyNodes(graph, layers);
      
      const crossingReducedLayers = reduceCrossings(augmentedLayers, augmentedGraph);
      positionNodes(crossingReducedLayers, augmentedGraph);
      
      // Repaint all connections
      instance.repaintEverything();
      updateEdgeGlow();
    }
    
    function addDummyNodes(graph, layers) {
      let dummyNodeCounter = 0;
      const newNodes = new Map(graph.nodes);
      const newEdges = new Map(JSON.parse(JSON.stringify(Array.from(graph.edges))));
      const newLayers = layers.map(layer => [...layer]);

      for (let i = 0; i < layers.length; i++) {
        for (const u of layers[i]) {
          const uNode = newNodes.get(u);
          if (!uNode) continue;

          // Make a copy of outEdges to iterate over, as we might modify the original
          const outEdges = [...uNode.outEdges];
          for (const v of outEdges) {
            const vNode = newNodes.get(v);
            if (!vNode) continue;
            
            const uLayer = uNode.layer;
            const vLayer = vNode.layer;
            
            if (vLayer > uLayer + 1) {
              // Remove original edge
              uNode.outEdges = uNode.outEdges.filter(id => id !== v);
              vNode.inEdges = vNode.inEdges.filter(id => id !== u);
              const uEdges = newEdges.get(u) || [];
              newEdges.set(u, uEdges.filter(id => id !== v));

              let parent = u;
              for (let j = uLayer + 1; j < vLayer; j++) {
                const dummyId = `dummy_${dummyNodeCounter++}`;
                const dummyNode = {
                  id: dummyId,
                  isDummy: true,
                  inEdges: [parent],
                  outEdges: [],
                  layer: j
                };

                // Add dummy node to graph and layers
                newNodes.set(dummyId, dummyNode);
                if (!newLayers[j]) newLayers[j] = [];
                newLayers[j].push(dummyId);
                
                // Rewire previous node to point to dummy
                newNodes.get(parent).outEdges.push(dummyId);

                // Update edges map
                const parentEdges = newEdges.get(parent) || [];
                if (!parentEdges.includes(dummyId)) {
                    parentEdges.push(dummyId);
                    newEdges.set(parent, parentEdges);
                }
                
                parent = dummyId;
              }
              
              // Connect last dummy node to original target
              newNodes.get(parent).outEdges.push(v);
              vNode.inEdges.push(parent);

              // Update edges map
              const parentEdges = newEdges.get(parent) || [];
              if (!parentEdges.includes(v)) {
                parentEdges.push(v);
                newEdges.set(parent, parentEdges);
              }
            }
          }
        }
      }
      
      const finalGraph = { nodes: newNodes, edges: newEdges };
      return { graph: finalGraph, layers: newLayers };
    }

    function buildDirectedGraph(nodes, connections) {
      const graph = {
        nodes: new Map(),
        edges: new Map()
      };
      
      // Initialize nodes
      nodes.forEach(node => {
        const index = parseInt(node.dataset.opIndex);
        graph.nodes.set(index, {
          id: index,
          element: node,
          inEdges: [],
          outEdges: [],
          layer: -1
        });
        graph.edges.set(index, []);
      });
      
      // Add edges
      connections.forEach(conn => {
        if (graph.nodes.has(conn.source_index) && graph.nodes.has(conn.target_index)) {
          const sourceNode = graph.nodes.get(conn.source_index);
          const targetNode = graph.nodes.get(conn.target_index);
          
          // Avoid duplicate edges
          if (!sourceNode.outEdges.includes(conn.target_index)) {
            sourceNode.outEdges.push(conn.target_index);
          }
          if (!targetNode.inEdges.includes(conn.source_index)) {
            targetNode.inEdges.push(conn.source_index);
          }
          
          const edgeList = graph.edges.get(conn.source_index) || [];
          if (!edgeList.includes(conn.target_index)) {
            edgeList.push(conn.target_index);
            graph.edges.set(conn.source_index, edgeList);
          }
        }
      });
      
      return graph;
    }
    
    function assignLayers(graph) {
      const layers = [];
      const visited = new Set();
      const visiting = new Set();
      
      // Assign layers using longest path from sources
      function assignLayer(nodeId) {
        if (visiting.has(nodeId)) return 0; // Cycle detection
        if (visited.has(nodeId)) return graph.nodes.get(nodeId).layer;
        
        visiting.add(nodeId);
        const node = graph.nodes.get(nodeId);
        
        let maxParentLayer = -1;
        node.inEdges.forEach(parentId => {
          maxParentLayer = Math.max(maxParentLayer, assignLayer(parentId));
        });
        
        node.layer = maxParentLayer + 1;
        visited.add(nodeId);
        visiting.delete(nodeId);
        
        // Add to layers array
        while (layers.length <= node.layer) {
          layers.push([]);
        }
        layers[node.layer].push(nodeId);
        
        return node.layer;
      }
      
      // Process all nodes
      graph.nodes.forEach((node, nodeId) => {
        if (!visited.has(nodeId)) {
          assignLayer(nodeId);
        }
      });
      
      return layers;
    }
    
    function reduceCrossings(layers, graph) {
      // Simple crossing reduction using barycenter method
      const maxIterations = 4;
      
      for (let i = 0; i < maxIterations; i++) {
        // Forward pass
        for (let l = 1; l < layers.length; l++) {
          layers[l].sort((a, b) => {
            const barycenterA = calculateBarycenter(a, graph.nodes.get(a).inEdges, layers[l-1], graph);
            const barycenterB = calculateBarycenter(b, graph.nodes.get(b).inEdges, layers[l-1], graph);
            return barycenterA - barycenterB;
          });
        }
        
        // Backward pass
        for (let l = layers.length - 2; l >= 0; l--) {
          layers[l].sort((a, b) => {
            const barycenterA = calculateBarycenter(a, graph.nodes.get(a).outEdges, layers[l+1], graph);
            const barycenterB = calculateBarycenter(b, graph.nodes.get(b).outEdges, layers[l+1], graph);
            return barycenterA - barycenterB;
          });
        }
      }
      
      return layers;
    }
    
    function calculateBarycenter(nodeId, connectedNodes, targetLayer, graph) {
      if (connectedNodes.length === 0) {
          // If a node has no connections in the current direction, 
          // return a default position
          return 0;
      }
      
      let sum = 0;
      let count = 0;
      
      connectedNodes.forEach(connectedId => {
        const index = targetLayer.indexOf(connectedId);
        if (index !== -1) {
          sum += index;
          count++;
        }
      });
      
      return count > 0 ? sum / count : 0;
    }
    
    function positionNodes(layers, graph) {
      const canvasRect = canvas.getBoundingClientRect();
      const layerHeight = 180;
      const nodeSpacing = 350; // Increased spacing for wider nodes
      const startY = 80;
      
      const positions = new Map();

      layers.forEach((layer, layerIndex) => {
        const y = startY + layerIndex * layerHeight;
        const layerWidth = layer.length * nodeSpacing;
        const startX = Math.max(50, (canvasRect.width - layerWidth) / 2);
        
        layer.forEach((nodeId, position) => {
          const x = startX + position * nodeSpacing;
          positions.set(nodeId, { x, y });
        });
      });
      
      graph.nodes.forEach((node, nodeId) => {
        if (!node.isDummy) {
          const element = node.element;
          const pos = positions.get(nodeId);
          if (element && pos) {
            element.style.left = (pos.x + currentPanX) + 'px';
            element.style.top = (pos.y + currentPanY) + 'px';
            instance.revalidate(element);
          }
        }
      });
    }

    canvas.addEventListener('dragover', e => e.preventDefault());
    canvas.addEventListener('drop', e => {
      e.preventDefault();
      const fqcn = e.dataTransfer.getData('text/plain');
      const opTemplate = document.querySelector(`[data-fqcn="${fqcn}"]`);
      const params = JSON.parse(opTemplate.dataset.params);
      const metadata = JSON.parse(opTemplate.dataset.metadata);
      const node = addNode(fqcn, params, e.offsetX, e.offsetY, metadata);
      
      // Assign a temporary index for new nodes
      const existingNodes = document.querySelectorAll('.node');
      node.dataset.opIndex = existingNodes.length - 1;
      
      // Don't automatically update connections when dropping new nodes
      // Let users manually connect them via the connection dialog
    });

    function addNode(fqcn, params, x, y, metadata = null) {
      const node = document.createElement('div');
      node.className = 'node';
      node.id = 'node' + (counter++);
      node.style.left = (x - currentPanX) + 'px';
      node.style.top = (y - currentPanY) + 'px';
      node.dataset.fqcn = fqcn;

      const title = document.createElement('div');
      title.className = 'node-title';
      title.textContent = fqcn.split('.').pop();
      node.appendChild(title);

      // Info button for docstring
      if (metadata && metadata.docstring !== undefined) {
        const infoBtnNode = document.createElement('div');
        infoBtnNode.className = 'info-btn';
        infoBtnNode.textContent = 'i';
        infoBtnNode.addEventListener('click', (e) => {
          e.stopPropagation();
          showDocModal(metadata.docstring || '', fqcn.split('.').pop());
        });
        node.appendChild(infoBtnNode);
      }

      const varsDiv = document.createElement('div');
      varsDiv.className = 'node-vars';
      
      // Create input fields for input parameters dynamically
      if (metadata && metadata.input_params && metadata.input_params.length > 0) {
        metadata.input_params.forEach(paramName => {
          const inputGroup = document.createElement('div');
          inputGroup.innerHTML = `<label>${paramName}:</label><input data-input="${paramName}" type="text" placeholder="${paramName}">`;
          varsDiv.appendChild(inputGroup);
          
          const inputField = inputGroup.querySelector('input');
          inputField.addEventListener('change', (e) => {
            updateNodeAndTileInputs(node.id, paramName, e.target.value);
            // Don't automatically update connections when changing input variables
            // Users should manually connect nodes via the connection dialog
          });
        });
      }
      
      // Create input fields for output parameters dynamically
      if (metadata && metadata.output_params && metadata.output_params.length > 0) {
        metadata.output_params.forEach(paramName => {
          const outputGroup = document.createElement('div');
          outputGroup.innerHTML = `<label>${paramName}:</label><input data-output="${paramName}" type="text" placeholder="${paramName}">`;
          varsDiv.appendChild(outputGroup);
          
          const outputField = outputGroup.querySelector('input');
          outputField.addEventListener('change', (e) => {
            updateNodeAndTileInputs(node.id, paramName, e.target.value);
            // Don't automatically update connections when changing output variables
            // Users should manually connect nodes via the connection dialog
          });
        });
      }
      
      // Fallback: if no metadata, create generic input/output fields
      if (!metadata || ((!metadata.input_params || metadata.input_params.length === 0) && 
                        (!metadata.output_params || metadata.output_params.length === 0))) {
        const inputGroup = document.createElement('div');
        inputGroup.innerHTML = '<label>Input Variable:</label><input data-input="input_variable" type="text" placeholder="input_var">';
        varsDiv.appendChild(inputGroup);
        
        const outputGroup = document.createElement('div');
        outputGroup.innerHTML = '<label>Output Variable:</label><input data-output="output_variable" type="text" placeholder="output_var">';
        varsDiv.appendChild(outputGroup);
        
        // Add change listeners to generic input/output variable fields
        const inputField = inputGroup.querySelector('input');
        const outputField = outputGroup.querySelector('input');
        inputField.addEventListener('change', (e) => {
          updateNodeAndTileInputs(node.id, 'input_variable', e.target.value);
          // Don't automatically update connections when changing input variables
          // Users should manually connect nodes via the connection dialog
        });
        outputField.addEventListener('change', (e) => {
          updateNodeAndTileInputs(node.id, 'output_variable', e.target.value);
          // Don't automatically update connections when changing output variables
          // Users should manually connect nodes via the connection dialog
        });
      }
      
      node.appendChild(varsDiv);

      // Create connectors
      const outAnchor = document.createElement('div');
      outAnchor.className = 'connector output';
      outAnchor.dataset.role = 'out';
      node.appendChild(outAnchor);

      const inAnchor = document.createElement('div');
      inAnchor.className = 'connector input';
      inAnchor.dataset.role = 'in';
      node.appendChild(inAnchor);

      // Create delete button
      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'delete-node';
      deleteBtn.textContent = '×';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteNode(node);
      });
      node.appendChild(deleteBtn);

      // Add click handler for selection with multi-select support
      node.addEventListener('click', (e) => {
        e.stopPropagation();
        
        if (e.ctrlKey || e.metaKey) {
          // Multi-select mode
          toggleNodeSelection(node, true);
        } else {
          // Single select mode
          toggleNodeSelection(node, false);
        }
      });

      canvas.appendChild(node);
      // Make node draggable with group support
      instance.draggable(node, {
        start: function(params) {
          if (selectedNodes.size > 1 && selectedNodes.has(node)) {
            // Capture original positions for each selected node
            groupDragData.active = true;
            groupDragData.draggingNode = node;
            groupDragData.originals.clear();
            selectedNodes.forEach(n => {
              groupDragData.originals.set(n, {
                left: parseInt(n.style.left) || 0,
                top: parseInt(n.style.top) || 0
              });
            });
          } else {
            groupDragData.active = false;
          }
        },
        drag: function(params) {
          if (groupDragData.active && groupDragData.draggingNode === node) {
            const orig = groupDragData.originals.get(node);
            if (!orig) return;
            const currentLeft = parseInt(node.style.left) || 0;
            const currentTop = parseInt(node.style.top) || 0;
            const deltaX = currentLeft - orig.left;
            const deltaY = currentTop - orig.top;
            groupDragData.originals.forEach((pos, n) => {
              if (n !== node) {
                n.style.left = (pos.left + deltaX) + 'px';
                n.style.top = (pos.top + deltaY) + 'px';
                instance.revalidate(n);
              }
            });
          }
        },
        stop: function(params) {
          groupDragData.active = false;
          groupDragData.draggingNode = null;
          updateEdgeGlow();
        }
      });
      instance.makeSource(outAnchor, {
        anchor: 'Center',
        connector: ['Bezier', { curviness: 30 }],
        maxConnections: -1
      });
      instance.makeTarget(inAnchor, {
        anchor: 'Center',
        connector: ['Bezier', { curviness: 30 }],
        maxConnections: -1
      });
      
      // Create parameter tile
      const tile = createParamTile(node, fqcn, params, metadata);
      
      // Sync tile inputs with node inputs for input/output parameters
      if (metadata && metadata.input_params) {
        metadata.input_params.forEach(paramName => {
          const nodeInput = node.querySelector(`input[data-input="${paramName}"]`);
          const tileInput = tile.querySelector(`input[data-param="${paramName}"]`);
          if (params[paramName] && nodeInput && tileInput) {
            nodeInput.value = params[paramName];
            tileInput.value = params[paramName];
          }
        });
      }
      
      if (metadata && metadata.output_params) {
        metadata.output_params.forEach(paramName => {
          const nodeOutput = node.querySelector(`input[data-output="${paramName}"]`);
          const tileOutput = tile.querySelector(`input[data-param="${paramName}"]`);
          if (params[paramName] && nodeOutput && tileOutput) {
            nodeOutput.value = params[paramName];
            tileOutput.value = params[paramName];
          }
        });
      }
      
      // Fallback for generic input/output variables
      if (!metadata || ((!metadata.input_params || metadata.input_params.length === 0) && 
                        (!metadata.output_params || metadata.output_params.length === 0))) {
        const nodeInput = node.querySelector('input[data-input="input_variable"]');
        const nodeOutput = node.querySelector('input[data-output="output_variable"]');
        const tileInput = tile.querySelector('input[data-param="input_variable"]');
        const tileOutput = tile.querySelector('input[data-param="output_variable"]');

        if (params.input_variable && nodeInput && tileInput) {
          nodeInput.value = params.input_variable;
          tileInput.value = params.input_variable;
        }
        if (params.output_variable && nodeOutput && tileOutput) {
          nodeOutput.value = params.output_variable;
          tileOutput.value = params.output_variable;
        }
      }
      
      return node;
    }

    function buildOps() {
      const nodes = Array.from(document.querySelectorAll('.node:not(.deleted)'));
      
      // Sort nodes by their current visual order (top to bottom)
      nodes.sort((a, b) => {
        const aTop = parseInt(a.style.top);
        const bTop = parseInt(b.style.top);
        return aTop - bTop;
      });
      
      const ops = [];
      nodes.forEach((node, index) => {
        // Update the node's index to match the current order
        node.dataset.opIndex = index;
        
        const args = {};
        
        // Get parameters from the param tile
        const paramInputs = document.querySelectorAll(`input[data-node-id="${node.id}"][data-param]`);
        paramInputs.forEach(inp => {
          if (inp.value) args[inp.dataset.param] = parseValue(inp.value);
        });
        
        ops.push({class: node.dataset.fqcn, args: args});
      });
      return ops;
    }

    function parseValue(value) {
        const trimmed = value.trim();
        if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
            try {
                // Attempt to parse as JSON
                return JSON.parse(trimmed);
            } catch (e) {
                // Fallback to string if not valid JSON
                return value;
            }
        }
        return value;
    }

    // Canvas panning functionality
    function panAllNodes(deltaX, deltaY) {
      const nodes = document.querySelectorAll('.node');
      nodes.forEach(node => {
        const currentX = parseInt(node.style.left) || 0;
        const currentY = parseInt(node.style.top) || 0;
        node.style.left = (currentX + deltaX) + 'px';
        node.style.top = (currentY + deltaY) + 'px';
        
        // Notify jsPlumb that the node has moved
        instance.revalidate(node);
      });
      
      // Update current pan position
      currentPanX += deltaX;
      currentPanY += deltaY;
      
      // Repaint connections
      instance.repaintEverything();
      updateEdgeGlow();
    }
    
    canvas.addEventListener('mousedown', (e) => {
      if (e.target === canvas) {
        isPanning = true;
        panStartX = e.clientX;
        panStartY = e.clientY;
        canvas.classList.add('dragging');
        e.preventDefault();
      }
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (isPanning) {
        const deltaX = e.clientX - panStartX;
        const deltaY = e.clientY - panStartY;
        
        panAllNodes(deltaX, deltaY);
        
        panStartX = e.clientX;
        panStartY = e.clientY;
        e.preventDefault();
      }
    });
    
    canvas.addEventListener('mouseup', (e) => {
      if (isPanning) {
        isPanning = false;
        canvas.classList.remove('dragging');
      }
    });
    
    canvas.addEventListener('mouseleave', (e) => {
      if (isPanning) {
        isPanning = false;
        canvas.classList.remove('dragging');
      }
    });

    // Add vertical scrolling support - works like dragging but only vertically
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      
      // Calculate scroll delta with reduced sensitivity
      const deltaY = -e.deltaY * 0.5;
      
      // Only move nodes vertically, similar to dragging behavior
      const nodes = document.querySelectorAll('.node');
      nodes.forEach(node => {
        const currentY = parseInt(node.style.top) || 0;
        const newY = currentY + deltaY;
        
        // Prevent nodes from going to invalid positions
        if (newY > -1000 && newY < 10000) {
          node.style.top = newY + 'px';
        }
      });
      
      // Update current pan position
      currentPanY += deltaY;
      
      // Revalidate connections without full repaint to avoid SVG errors
      nodes.forEach(node => {
        instance.revalidate(node);
      });
    });

          // Track mouse position for paste positioning
    canvas.addEventListener('mousemove', (e) => {
      lastMouseX = e.offsetX;
      lastMouseY = e.offsetY;
    });

    // Clear selection when clicking on canvas
    canvas.addEventListener('click', (e) => {
      if (e.target === canvas && !isPanning) {
        clearSelection();
      }
    });
    
    // Keyboard shortcuts for copy-paste
    document.addEventListener('keydown', (e) => {
      // Don't trigger shortcuts when typing in input fields
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
      }
      
      if (e.ctrlKey || e.metaKey) {
        switch(e.key) {
          case 'c':
          case 'C':
            e.preventDefault();
            copySelectedNodes();
            updateButtonStates();
            break;
          case 'v':
          case 'V':
            e.preventDefault();
            pasteNodes();
            updateButtonStates();
            break;
          case 'a':
          case 'A':
            e.preventDefault();
            // Select all nodes
            clearSelection();
            document.querySelectorAll('.node:not(.deleted)').forEach(node => {
              selectedNodes.add(node);
              node.classList.add('multi-selected');
            });
            updateButtonStates();
            break;
        }
      }
      
      // Delete selected nodes
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selectedNodes.size > 0) {
          e.preventDefault();
          selectedNodes.forEach(node => {
            deleteNode(node);
          });
          clearSelection();
        }
      }
      
      // Escape to clear selection
      if (e.key === 'Escape') {
        clearSelection();
      }
    });

    document.getElementById('submit-overlay').onclick = async () => {
      // Before submitting, permanently remove any node pending deletion
      if (lastDeletedNode) {
        permanentlyRemoveNode(lastDeletedNode);
        lastDeletedNode = null;
        document.getElementById('undo-banner').style.display = 'none';
      }
      
      const ops = buildOps();
      if (ops.length === 0) {
        alert('No operations to submit');
        return;
      }
      
      try {
        const res = await authenticatedFetch('/enqueue', {
          method: 'POST',
          body: JSON.stringify({
            task_name: 'initialize_pipeline', 
            pipeline: ops,
            name: 'PipelineBuilder Pipeline'
          })
        });
        
        if (res.ok) {
          alert('Pipeline submitted successfully');
        } else {
          const errorText = await res.text();
          throw new Error('Failed to submit pipeline: ' + errorText);
        }
      } catch (error) {
        console.error('Pipeline submission error:', error);
        alert('Pipeline submission failed: ' + error.message);
      }
    };

    document.getElementById('load-prefab').onclick = async () => {
      const prefabSelect = document.getElementById('prefab-select');
      const name = prefabSelect.value;
      if (!name) return;
      
      // Close modal
      prefabModal.style.display = 'none';
      
      const res = await authenticatedFetch(`/load_prefab?name=${encodeURIComponent(name)}`, {
        method: 'GET'
      });
      if (res.ok) {
        const data = await res.json();
        loadPipeline(data);
      }
    };

    document.getElementById('optimize-layout').onclick = async () => {
      // Before optimizing, permanently remove any node pending deletion
      if (lastDeletedNode) {
        permanentlyRemoveNode(lastDeletedNode);
        lastDeletedNode = null;
        document.getElementById('undo-banner').style.display = 'none';
      }
      const ops = buildOps();
      if (ops.length === 0) return;
      
      try {
        const opsParam = encodeURIComponent(JSON.stringify(ops));
        const res = await authenticatedFetch(`/analyze_pipeline?ops=${opsParam}`, {
          method: 'GET'
        });
        
        if (res.ok) {
          const data = await res.json();
          optimizeLayout(data.connections);
        }
      } catch (error) {
        console.error('Error optimizing layout:', error);
      }
    };

    function deleteNode(node) {
      // If there's a previously deleted node, remove it for good.
      if (lastDeletedNode) {
        permanentlyRemoveNode(lastDeletedNode);
      }
      
      const paramTile = document.querySelector(`.param-tile[data-node-id="${node.id}"]`);
      
      // Store node and tile for potential undo
      lastDeletedNode = { node, tile: paramTile };
      
      // Hide the node and mark as deleted
      node.classList.add('deleted');
      node.style.display = 'none';
      if (paramTile) {
          paramTile.classList.add('deleted');
          paramTile.style.display = 'none';
      }
      
      // Hide connections associated with the node
      const allConnections = instance.getAllConnections();
      const nodeConnections = allConnections.filter(conn => 
        conn.source === node || conn.target === node
      );
      
      // Store connections for restoration
      node.dataset.hiddenConnections = JSON.stringify(nodeConnections.map(conn => ({
        sourceId: conn.source.id,
        targetId: conn.target.id,
        sourceEndpoint: conn.endpoints[0].anchor.type,
        targetEndpoint: conn.endpoints[1].anchor.type
      })));
      
      // Remove connections
      nodeConnections.forEach(conn => instance.deleteConnection(conn));
      
      // Show undo banner
      document.getElementById('undo-banner').style.display = 'block';
    }

    function permanentlyRemoveNode({ node, tile }) {
        if (tile) tile.remove();
        instance.remove(node); // This also removes the element from the DOM
    }
    
    function undoDelete() {
      if (!lastDeletedNode) return;
      
      const { node, tile } = lastDeletedNode;
      
      // Un-hide the node and tile
      node.classList.remove('deleted');
      node.style.display = '';
      if (tile) {
        tile.classList.remove('deleted');
        tile.style.display = '';
      }

      // Restore connections
      if (node.dataset.hiddenConnections) {
        try {
          const connectionData = JSON.parse(node.dataset.hiddenConnections);
          isProgrammaticConnection = true;
          connectionData.forEach(connData => {
            const sourceNode = document.getElementById(connData.sourceId);
            const targetNode = document.getElementById(connData.targetId);
            
            if (sourceNode && targetNode) {
              instance.connect({
                source: sourceNode.querySelector('[data-role="out"]'),
                target: targetNode.querySelector('[data-role="in"]'),
                connector: ['Bezier', { curviness: 30 }],
                anchors: ['Center', 'Center']
              });
            }
          });
          isProgrammaticConnection = false;
          
          // Clear the stored connection data
          delete node.dataset.hiddenConnections;
        } catch (e) {
          console.warn('Could not restore connections:', e);
        }
      }
      
      // Clear undo state
      lastDeletedNode = null;
      document.getElementById('undo-banner').style.display = 'none';
    }
    
    function updateNodeAndTileInputs(nodeId, paramName, value) {
      // Update param tile
      const tileInput = document.querySelector(`#param-tiles input[data-node-id="${nodeId}"][data-param="${paramName}"]`);
      if (tileInput && tileInput.value !== value) {
        tileInput.value = value;
      }
      
      // Update node input if applicable (check for input parameter)
      const nodeInput = document.querySelector(`#${nodeId} input[data-input="${paramName}"]`);
      if (nodeInput && nodeInput.value !== value) {
        nodeInput.value = value;
      }
      
      // Update node output if applicable (check for output parameter)
      const nodeOutput = document.querySelector(`#${nodeId} input[data-output="${paramName}"]`);
      if (nodeOutput && nodeOutput.value !== value) {
        nodeOutput.value = value;
      }
    }

    // Handle connection events
    instance.bind('connection', function(info) {
      // Only show connection dialog for user-initiated connections
      if (!isLoadingPipeline && !isProgrammaticConnection) {
        // Get the actual node elements (the connection endpoints are inside the nodes)
        const sourceNode = info.source.closest('.node');
        const targetNode = info.target.closest('.node');
        

        
        if (sourceNode && targetNode) {
          handleNewConnection(sourceNode, targetNode);
        }
      }
    });

    loadOps();
    loadPrefabs();
    loadCurrentPipeline();

    // Wire up undo button
    document.getElementById('undo-delete').onclick = undoDelete;
    
    // Initialize button states
    updateButtonStates();

    // Docstring modal elements
    const docModal = document.getElementById('doc-modal');
    const docModalContent = document.getElementById('doc-modal-content');
    const docModalTitle = document.getElementById('doc-modal-title');
    const docModalClose = document.getElementById('doc-modal-close');

    function showDocModal(docstring = '', title = 'Documentation') {
      docModalTitle.textContent = title;
      docModalContent.textContent = docstring || 'No documentation available.';
      docModal.style.display = 'block';
    }

    docModalClose.addEventListener('click', () => {
      docModal.style.display = 'none';
    });

    // Close modal when clicking outside content
    docModal.addEventListener('click', (e) => {
      if (e.target === docModal) {
        docModal.style.display = 'none';
      }
    });

    // Group drag support
    const groupDragData = {
      active: false,
      originals: new Map(), // node -> {left, top}
      draggingNode: null
    };

    // ---------------------------------------------------------------------
    // Save current pipeline as prefab
    // ---------------------------------------------------------------------
    document.getElementById('save-prefab-btn').onclick = async () => {
      const ops = buildOps();
      if (ops.length === 0) {
        alert('No operations to save as a prefab');
        return;
      }

      // Ask user for the prefab name
      const prefabName = prompt('Enter a name for the prefab:', 'my_prefab');
      if (!prefabName || !prefabName.trim()) {
        return; // User cancelled or empty
      }

      try {
        const opsParam = encodeURIComponent(JSON.stringify(ops));
        const url = `/save_prefab?name=${encodeURIComponent(prefabName.trim())}&pipeline=${opsParam}`;
        const res = await authenticatedFetch(url, { method: 'GET' });
        const data = await res.json();

        if (data.status === 'success') {
          alert(`Prefab saved successfully as '${prefabName}'.`);
          // Refresh the prefab dropdown so the new prefab appears
          prefabSelect.innerHTML = "<option value=''>-- Select a prefab --</option>";
          await loadPrefabs();
        } else {
          alert('Failed to save prefab: ' + (data.message || 'Unknown error'));
        }
      } catch (error) {
        console.error('Error saving prefab:', error);
        alert('Error saving prefab: ' + error.message);
      }
    };

    // ---------------------------------------------------------------------
    // Edge glow helper
    // ---------------------------------------------------------------------
    const glowTop = document.querySelector('.edge-glow.top');
    const glowBottom = document.querySelector('.edge-glow.bottom');
    const glowLeft = document.querySelector('.edge-glow.left');
    const glowRight = document.querySelector('.edge-glow.right');

    function updateEdgeGlow() {
       const canvasRect = canvas.getBoundingClientRect();
       const nodes = document.querySelectorAll('.node:not(.deleted)');
       let showTop = false, showBottom = false, showLeft = false, showRight = false;

       nodes.forEach(node => {
         const nodeLeft = parseInt(node.style.left) || 0;
         const nodeTop = parseInt(node.style.top) || 0;
         const nodeWidth = node.offsetWidth || 150;
         const nodeHeight = node.offsetHeight || 100;
         
         // Check if node extends beyond visible canvas area
         // Nodes are positioned absolutely, so we check against 0,0 to canvas width/height
         if (nodeTop < 25) showTop = true;
         if (nodeTop + nodeHeight > canvasRect.height - 25) showBottom = true;
         if (nodeLeft < 25) showLeft = true;
         if (nodeLeft + nodeWidth > canvasRect.width - 25) showRight = true;
       });

       glowTop.style.opacity = showTop ? 1 : 0;
       glowBottom.style.opacity = showBottom ? 1 : 0;
       glowLeft.style.opacity = showLeft ? 1 : 0;
       glowRight.style.opacity = showRight ? 1 : 0;
      
      // Debug logging
      if (showTop || showBottom || showLeft || showRight) {
        console.log('Edge glow:', {showTop, showBottom, showLeft, showRight, canvasRect});
      }
     }

    // Periodic check (fallback) in case some events missed
    setInterval(updateEdgeGlow, 1000);
  </script>
</body>
</html>